"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2017 The Ray Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import abc
import collections.abc
import grpc
import grpc.aio
import model.ray.serve_pb2
import typing

_T = typing.TypeVar('_T')

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta):
    ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore
    ...

class RayServeAPIServiceStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    ListApplications: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.ListApplicationsRequest,
        model.ray.serve_pb2.ListApplicationsResponse,
    ]
    Healthz: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.HealthzRequest,
        model.ray.serve_pb2.HealthzResponse,
    ]

class RayServeAPIServiceAsyncStub:
    ListApplications: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.ListApplicationsRequest,
        model.ray.serve_pb2.ListApplicationsResponse,
    ]
    Healthz: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.HealthzRequest,
        model.ray.serve_pb2.HealthzResponse,
    ]

class RayServeAPIServiceServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def ListApplications(
        self,
        request: model.ray.serve_pb2.ListApplicationsRequest,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.ListApplicationsResponse, collections.abc.Awaitable[model.ray.serve_pb2.ListApplicationsResponse]]: ...
    @abc.abstractmethod
    def Healthz(
        self,
        request: model.ray.serve_pb2.HealthzRequest,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.HealthzResponse, collections.abc.Awaitable[model.ray.serve_pb2.HealthzResponse]]: ...

def add_RayServeAPIServiceServicer_to_server(servicer: RayServeAPIServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class UserDefinedServiceStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    __call__: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]
    Method1: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]
    Method2: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage2,
        model.ray.serve_pb2.UserDefinedResponse2,
    ]
    Streaming: grpc.UnaryStreamMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]

class UserDefinedServiceAsyncStub:
    __call__: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]
    Method1: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]
    Method2: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage2,
        model.ray.serve_pb2.UserDefinedResponse2,
    ]
    Streaming: grpc.aio.UnaryStreamMultiCallable[
        model.ray.serve_pb2.UserDefinedMessage,
        model.ray.serve_pb2.UserDefinedResponse,
    ]

class UserDefinedServiceServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def __call__(
        self,
        request: model.ray.serve_pb2.UserDefinedMessage,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.UserDefinedResponse, collections.abc.Awaitable[model.ray.serve_pb2.UserDefinedResponse]]: ...
    @abc.abstractmethod
    def Method1(
        self,
        request: model.ray.serve_pb2.UserDefinedMessage,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.UserDefinedResponse, collections.abc.Awaitable[model.ray.serve_pb2.UserDefinedResponse]]: ...
    @abc.abstractmethod
    def Method2(
        self,
        request: model.ray.serve_pb2.UserDefinedMessage2,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.UserDefinedResponse2, collections.abc.Awaitable[model.ray.serve_pb2.UserDefinedResponse2]]: ...
    @abc.abstractmethod
    def Streaming(
        self,
        request: model.ray.serve_pb2.UserDefinedMessage,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[model.ray.serve_pb2.UserDefinedResponse], collections.abc.AsyncIterator[model.ray.serve_pb2.UserDefinedResponse]]: ...

def add_UserDefinedServiceServicer_to_server(servicer: UserDefinedServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class FruitServiceStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    FruitStand: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.FruitAmounts,
        model.ray.serve_pb2.FruitCosts,
    ]

class FruitServiceAsyncStub:
    FruitStand: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.FruitAmounts,
        model.ray.serve_pb2.FruitCosts,
    ]

class FruitServiceServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def FruitStand(
        self,
        request: model.ray.serve_pb2.FruitAmounts,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.FruitCosts, collections.abc.Awaitable[model.ray.serve_pb2.FruitCosts]]: ...

def add_FruitServiceServicer_to_server(servicer: FruitServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class RayServeBenchmarkServiceStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    grpc_call: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.ArrayData,
        model.ray.serve_pb2.ModelOutput,
    ]
    call_with_string: grpc.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.StringData,
        model.ray.serve_pb2.ModelOutput,
    ]

class RayServeBenchmarkServiceAsyncStub:
    grpc_call: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.ArrayData,
        model.ray.serve_pb2.ModelOutput,
    ]
    call_with_string: grpc.aio.UnaryUnaryMultiCallable[
        model.ray.serve_pb2.StringData,
        model.ray.serve_pb2.ModelOutput,
    ]

class RayServeBenchmarkServiceServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def grpc_call(
        self,
        request: model.ray.serve_pb2.ArrayData,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.ModelOutput, collections.abc.Awaitable[model.ray.serve_pb2.ModelOutput]]: ...
    @abc.abstractmethod
    def call_with_string(
        self,
        request: model.ray.serve_pb2.StringData,
        context: _ServicerContext,
    ) -> typing.Union[model.ray.serve_pb2.ModelOutput, collections.abc.Awaitable[model.ray.serve_pb2.ModelOutput]]: ...

def add_RayServeBenchmarkServiceServicer_to_server(servicer: RayServeBenchmarkServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
