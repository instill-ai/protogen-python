"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import artifact.artifact.v1alpha.file_pb2
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Chunk(google.protobuf.message.Message):
    """The Chunk message represents a chunk of data in the artifact system."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Type:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Chunk._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TYPE_UNSPECIFIED: Chunk._Type.ValueType  # 0
        """Unspecified."""
        TYPE_CONTENT: Chunk._Type.ValueType  # 1
        """Content."""
        TYPE_SUMMARY: Chunk._Type.ValueType  # 2
        """Summary."""
        TYPE_AUGMENTED: Chunk._Type.ValueType  # 3
        """Augmented."""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """Type describes the type of a chunk content."""

    TYPE_UNSPECIFIED: Chunk.Type.ValueType  # 0
    """Unspecified."""
    TYPE_CONTENT: Chunk.Type.ValueType  # 1
    """Content."""
    TYPE_SUMMARY: Chunk.Type.ValueType  # 2
    """Summary."""
    TYPE_AUGMENTED: Chunk.Type.ValueType  # 3
    """Augmented."""

    @typing_extensions.final
    class Reference(google.protobuf.message.Message):
        """Reference represents the position of a chunk within a file."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        START_FIELD_NUMBER: builtins.int
        END_FIELD_NUMBER: builtins.int
        @property
        def start(self) -> artifact.artifact.v1alpha.file_pb2.File.Position:
            """Start position of the chunk within the file."""
        @property
        def end(self) -> artifact.artifact.v1alpha.file_pb2.File.Position:
            """End position of the chunk within the file."""
        def __init__(
            self,
            *,
            start: artifact.artifact.v1alpha.file_pb2.File.Position | None = ...,
            end: artifact.artifact.v1alpha.file_pb2.File.Position | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> None: ...

    UID_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    RETRIEVABLE_FIELD_NUMBER: builtins.int
    TOKENS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    ORIGINAL_FILE_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    REFERENCE_FIELD_NUMBER: builtins.int
    MARKDOWN_REFERENCE_FIELD_NUMBER: builtins.int
    START_POS_FIELD_NUMBER: builtins.int
    END_POS_FIELD_NUMBER: builtins.int
    uid: builtins.str
    """The chunk uid (internal UUID, also used as id)."""
    id: builtins.str
    """The chunk id (same as uid)."""
    name: builtins.str
    """The resource name of the chunk.
    Format: `namespaces/{namespace}/catalogs/{catalog}/files/{file}/chunks/{chunk}`.
    """
    retrievable: builtins.bool
    """whether the chunk is retrievable"""
    tokens: builtins.int
    """tokens of the chunk"""
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """creation time of the chunk"""
    original_file_id: builtins.str
    """original file unique identifier"""
    type: global___Chunk.Type.ValueType
    """chunk type"""
    @property
    def reference(self) -> global___Chunk.Reference:
        """Reference to the position of the chunk within the original file."""
    @property
    def markdown_reference(self) -> global___Chunk.Reference:
        """Reference to the position of the chunk within the Markdown (source) file."""
    start_pos: builtins.int
    """start position of the chunk in the source file
    Deprecated: use markdown_reference instead
    """
    end_pos: builtins.int
    """end position of the chunk in the source file
    Deprecated: use markdown_reference instead
    """
    def __init__(
        self,
        *,
        uid: builtins.str = ...,
        id: builtins.str = ...,
        name: builtins.str = ...,
        retrievable: builtins.bool = ...,
        tokens: builtins.int = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        original_file_id: builtins.str = ...,
        type: global___Chunk.Type.ValueType = ...,
        reference: global___Chunk.Reference | None = ...,
        markdown_reference: global___Chunk.Reference | None = ...,
        start_pos: builtins.int = ...,
        end_pos: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time", b"create_time", "markdown_reference", b"markdown_reference", "reference", b"reference"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time", b"create_time", "end_pos", b"end_pos", "id", b"id", "markdown_reference", b"markdown_reference", "name", b"name", "original_file_id", b"original_file_id", "reference", b"reference", "retrievable", b"retrievable", "start_pos", b"start_pos", "tokens", b"tokens", "type", b"type", "uid", b"uid"]) -> None: ...

global___Chunk = Chunk

@typing_extensions.final
class ListChunksRequest(google.protobuf.message.Message):
    """ListChunksRequest represents a request to list chunks in the artifact system.
    The response will be a list of chunks based on the request, i.e., response will
    have chunks of the file with file_id and chunks specified in chunk_ids.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_ID_FIELD_NUMBER: builtins.int
    CATALOG_ID_FIELD_NUMBER: builtins.int
    FILE_ID_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    namespace_id: builtins.str
    """owner/namespace id"""
    catalog_id: builtins.str
    """catalog id"""
    file_id: builtins.str
    """file id"""
    page_size: builtins.int
    """The maximum number of chunks to return. If this parameter is unspecified,
    at most 100 chunks will be returned. The cap value for this parameter
    is 1000 (i.e. any value above that will be coerced to 1000).
    """
    page_token: builtins.str
    """Page token."""
    filter: builtins.str
    """Filter can hold an [AIP-160](https://google.aip.dev/160)-compliant filter expression.
    - `id="<uuid>"` or `uid="<uuid>"` - Filter by specific chunk ID/UID
    - `chunk_type="CHUNK_TYPE_TEXT"` - Filter by chunk type
    - `retrievable=true` - Filter by retrievable status

    **Examples**:
    - List specific chunks: `id="uuid1" OR id="uuid2"`
    - List text chunks: `chunk_type="CHUNK_TYPE_TEXT"`
    - List retrievable chunks: `retrievable=true`
    """
    def __init__(
        self,
        *,
        namespace_id: builtins.str = ...,
        catalog_id: builtins.str = ...,
        file_id: builtins.str = ...,
        page_size: builtins.int | None = ...,
        page_token: builtins.str | None = ...,
        filter: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_filter", b"_filter", "_page_size", b"_page_size", "_page_token", b"_page_token", "filter", b"filter", "page_size", b"page_size", "page_token", b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_filter", b"_filter", "_page_size", b"_page_size", "_page_token", b"_page_token", "catalog_id", b"catalog_id", "file_id", b"file_id", "filter", b"filter", "namespace_id", b"namespace_id", "page_size", b"page_size", "page_token", b"page_token"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_filter", b"_filter"]) -> typing_extensions.Literal["filter"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_page_size", b"_page_size"]) -> typing_extensions.Literal["page_size"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_page_token", b"_page_token"]) -> typing_extensions.Literal["page_token"] | None: ...

global___ListChunksRequest = ListChunksRequest

@typing_extensions.final
class ListChunksResponse(google.protobuf.message.Message):
    """ListChunksResponse represents a response containing a list of chunks in the artifact system."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNKS_FIELD_NUMBER: builtins.int
    @property
    def chunks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Chunk]:
        """repeated chunks"""
    def __init__(
        self,
        *,
        chunks: collections.abc.Iterable[global___Chunk] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunks", b"chunks"]) -> None: ...

global___ListChunksResponse = ListChunksResponse

@typing_extensions.final
class GetChunkRequest(google.protobuf.message.Message):
    """GetChunkRequest represents a request to get a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_ID_FIELD_NUMBER: builtins.int
    CATALOG_ID_FIELD_NUMBER: builtins.int
    FILE_ID_FIELD_NUMBER: builtins.int
    CHUNK_ID_FIELD_NUMBER: builtins.int
    namespace_id: builtins.str
    """Namespace ID."""
    catalog_id: builtins.str
    """Catalog ID."""
    file_id: builtins.str
    """File ID."""
    chunk_id: builtins.str
    """Chunk ID."""
    def __init__(
        self,
        *,
        namespace_id: builtins.str = ...,
        catalog_id: builtins.str = ...,
        file_id: builtins.str = ...,
        chunk_id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["catalog_id", b"catalog_id", "chunk_id", b"chunk_id", "file_id", b"file_id", "namespace_id", b"namespace_id"]) -> None: ...

global___GetChunkRequest = GetChunkRequest

@typing_extensions.final
class GetChunkResponse(google.protobuf.message.Message):
    """GetChunkResponse represents a response for getting a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def chunk(self) -> global___Chunk:
        """The chunk resource."""
    def __init__(
        self,
        *,
        chunk: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk", b"chunk"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk", b"chunk"]) -> None: ...

global___GetChunkResponse = GetChunkResponse

@typing_extensions.final
class UpdateChunkRequest(google.protobuf.message.Message):
    """UpdateChunkRequest represents a request to update a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_ID_FIELD_NUMBER: builtins.int
    CATALOG_ID_FIELD_NUMBER: builtins.int
    CHUNK_ID_FIELD_NUMBER: builtins.int
    RETRIEVABLE_FIELD_NUMBER: builtins.int
    namespace_id: builtins.str
    """Namespace ID."""
    catalog_id: builtins.str
    """Catalog ID."""
    chunk_id: builtins.str
    """Chunk ID."""
    retrievable: builtins.bool
    """whether the chunk is retrievable"""
    def __init__(
        self,
        *,
        namespace_id: builtins.str = ...,
        catalog_id: builtins.str = ...,
        chunk_id: builtins.str = ...,
        retrievable: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["catalog_id", b"catalog_id", "chunk_id", b"chunk_id", "namespace_id", b"namespace_id", "retrievable", b"retrievable"]) -> None: ...

global___UpdateChunkRequest = UpdateChunkRequest

@typing_extensions.final
class UpdateChunkResponse(google.protobuf.message.Message):
    """UpdateChunkResponse represents a response for updating a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def chunk(self) -> global___Chunk:
        """chunk"""
    def __init__(
        self,
        *,
        chunk: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk", b"chunk"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk", b"chunk"]) -> None: ...

global___UpdateChunkResponse = UpdateChunkResponse

@typing_extensions.final
class SearchChunksRequest(google.protobuf.message.Message):
    """SearchChunksRequest represents a request to search for similar chunks."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAMESPACE_ID_FIELD_NUMBER: builtins.int
    CATALOG_ID_FIELD_NUMBER: builtins.int
    TEXT_PROMPT_FIELD_NUMBER: builtins.int
    TOP_K_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    FILE_MEDIA_TYPE_FIELD_NUMBER: builtins.int
    FILE_IDS_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    namespace_id: builtins.str
    """ID of the namespace owning the catalog."""
    catalog_id: builtins.str
    """ID of the catalog."""
    text_prompt: builtins.str
    """Text prompt to look for similarities."""
    top_k: builtins.int
    """Top K. Default value: 5."""
    type: global___Chunk.Type.ValueType
    """Chunk type."""
    file_media_type: artifact.artifact.v1alpha.file_pb2.File.FileMediaType.ValueType
    """File media type."""
    @property
    def file_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """File IDs. When this field is provided, the response will return only
        chunks that belong to the specified file IDs.
        """
    @property
    def tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Tags to filter by. When multiple tags are provided, OR logic is applied.
        Note: File ID filter takes precedence over tags, as tags apply to files.
        """
    def __init__(
        self,
        *,
        namespace_id: builtins.str = ...,
        catalog_id: builtins.str = ...,
        text_prompt: builtins.str = ...,
        top_k: builtins.int = ...,
        type: global___Chunk.Type.ValueType = ...,
        file_media_type: artifact.artifact.v1alpha.file_pb2.File.FileMediaType.ValueType = ...,
        file_ids: collections.abc.Iterable[builtins.str] | None = ...,
        tags: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["catalog_id", b"catalog_id", "file_ids", b"file_ids", "file_media_type", b"file_media_type", "namespace_id", b"namespace_id", "tags", b"tags", "text_prompt", b"text_prompt", "top_k", b"top_k", "type", b"type"]) -> None: ...

global___SearchChunksRequest = SearchChunksRequest

@typing_extensions.final
class SearchChunksResponse(google.protobuf.message.Message):
    """SearchChunksResponse represents a response for searching similar chunks."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIMILAR_CHUNKS_FIELD_NUMBER: builtins.int
    @property
    def similar_chunks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SimilarityChunk]:
        """chunks"""
    def __init__(
        self,
        *,
        similar_chunks: collections.abc.Iterable[global___SimilarityChunk] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["similar_chunks", b"similar_chunks"]) -> None: ...

global___SearchChunksResponse = SearchChunksResponse

@typing_extensions.final
class SimilarityChunk(google.protobuf.message.Message):
    """SimilarityChunk represents a chunk with similarity score."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_ID_FIELD_NUMBER: builtins.int
    SIMILARITY_SCORE_FIELD_NUMBER: builtins.int
    TEXT_CONTENT_FIELD_NUMBER: builtins.int
    SOURCE_FILE_FIELD_NUMBER: builtins.int
    CHUNK_METADATA_FIELD_NUMBER: builtins.int
    chunk_id: builtins.str
    """chunk id"""
    similarity_score: builtins.float
    """similarity score"""
    text_content: builtins.str
    """content"""
    source_file: builtins.str
    """source file's name"""
    @property
    def chunk_metadata(self) -> global___Chunk:
        """chunk metadata"""
    def __init__(
        self,
        *,
        chunk_id: builtins.str = ...,
        similarity_score: builtins.float = ...,
        text_content: builtins.str = ...,
        source_file: builtins.str = ...,
        chunk_metadata: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk_metadata", b"chunk_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk_id", b"chunk_id", "chunk_metadata", b"chunk_metadata", "similarity_score", b"similarity_score", "source_file", b"source_file", "text_content", b"text_content"]) -> None: ...

global___SimilarityChunk = SimilarityChunk
