"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import artifact.v1alpha.file_pb2
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Chunk(google.protobuf.message.Message):
    """The Chunk message represents a chunk of data in the artifact system."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Type:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Chunk._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TYPE_UNSPECIFIED: Chunk._Type.ValueType  # 0
        """Unspecified."""
        TYPE_CONTENT: Chunk._Type.ValueType  # 1
        """Content."""
        TYPE_SUMMARY: Chunk._Type.ValueType  # 2
        """Summary."""
        TYPE_AUGMENTED: Chunk._Type.ValueType  # 3
        """Augmented."""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """Type describes the type of a chunk content."""

    TYPE_UNSPECIFIED: Chunk.Type.ValueType  # 0
    """Unspecified."""
    TYPE_CONTENT: Chunk.Type.ValueType  # 1
    """Content."""
    TYPE_SUMMARY: Chunk.Type.ValueType  # 2
    """Summary."""
    TYPE_AUGMENTED: Chunk.Type.ValueType  # 3
    """Augmented."""

    @typing.final
    class Reference(google.protobuf.message.Message):
        """Reference represents the position of a chunk within a file."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        START_FIELD_NUMBER: builtins.int
        END_FIELD_NUMBER: builtins.int
        @property
        def start(self) -> artifact.v1alpha.file_pb2.File.Position:
            """Start position of the chunk within the file."""

        @property
        def end(self) -> artifact.v1alpha.file_pb2.File.Position:
            """End position of the chunk within the file."""

        def __init__(
            self,
            *,
            start: artifact.v1alpha.file_pb2.File.Position | None = ...,
            end: artifact.v1alpha.file_pb2.File.Position | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["end", b"end", "start", b"start"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["end", b"end", "start", b"start"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    RETRIEVABLE_FIELD_NUMBER: builtins.int
    TOKENS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    ORIGINAL_FILE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    REFERENCE_FIELD_NUMBER: builtins.int
    MARKDOWN_REFERENCE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Field 1: The resource name of the chunk.
    Format:
    `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}/chunks/{chunk}`.
    """
    id: builtins.str
    """Field 2: The chunk id (unique identifier)."""
    retrievable: builtins.bool
    """===== Resource-specific fields start from field 3+ =====

    whether the chunk is retrievable
    """
    tokens: builtins.int
    """tokens of the chunk"""
    original_file: builtins.str
    """The resource name of the original file this chunk belongs to.
    Format:
    `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}`
    """
    type: global___Chunk.Type.ValueType
    """chunk type"""
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """creation time of the chunk"""

    @property
    def reference(self) -> global___Chunk.Reference:
        """Reference to the position of the chunk within the original file."""

    @property
    def markdown_reference(self) -> global___Chunk.Reference:
        """Reference to the position of the chunk within the Markdown (source) file."""

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        id: builtins.str = ...,
        retrievable: builtins.bool = ...,
        tokens: builtins.int = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        original_file: builtins.str = ...,
        type: global___Chunk.Type.ValueType = ...,
        reference: global___Chunk.Reference | None = ...,
        markdown_reference: global___Chunk.Reference | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["create_time", b"create_time", "markdown_reference", b"markdown_reference", "reference", b"reference"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["create_time", b"create_time", "id", b"id", "markdown_reference", b"markdown_reference", "name", b"name", "original_file", b"original_file", "reference", b"reference", "retrievable", b"retrievable", "tokens", b"tokens", "type", b"type"]) -> None: ...

global___Chunk = Chunk

@typing.final
class ListChunksRequest(google.protobuf.message.Message):
    """ListChunksRequest represents a request to list chunks in the artifact system.
    Follows AIP-132: https://google.aip.dev/132
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: builtins.str
    """The parent resource name.
    Format:
    `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}`
    """
    page_size: builtins.int
    """The maximum number of chunks to return. If this parameter is unspecified,
    at most 100 chunks will be returned. The cap value for this parameter
    is 1000 (i.e. any value above that will be coerced to 1000).
    """
    page_token: builtins.str
    """Page token."""
    filter: builtins.str
    """Filter can hold an [AIP-160](https://google.aip.dev/160)-compliant filter
    expression.
    - `id="<uuid>"` or `uid="<uuid>"` - Filter by specific chunk ID/UID
    - `chunk_type="CHUNK_TYPE_TEXT"` - Filter by chunk type
    - `retrievable=true` - Filter by retrievable status

    **Examples**:
    - List specific chunks: `id="uuid1" OR id="uuid2"`
    - List text chunks: `chunk_type="CHUNK_TYPE_TEXT"`
    - List retrievable chunks: `retrievable=true`
    """
    def __init__(
        self,
        *,
        parent: builtins.str = ...,
        page_size: builtins.int | None = ...,
        page_token: builtins.str | None = ...,
        filter: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_filter", b"_filter", "_page_size", b"_page_size", "_page_token", b"_page_token", "filter", b"filter", "page_size", b"page_size", "page_token", b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_filter", b"_filter", "_page_size", b"_page_size", "_page_token", b"_page_token", "filter", b"filter", "page_size", b"page_size", "page_token", b"page_token", "parent", b"parent"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_filter", b"_filter"]) -> typing.Literal["filter"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_page_size", b"_page_size"]) -> typing.Literal["page_size"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_page_token", b"_page_token"]) -> typing.Literal["page_token"] | None: ...

global___ListChunksRequest = ListChunksRequest

@typing.final
class ListChunksResponse(google.protobuf.message.Message):
    """ListChunksResponse represents a response containing a list of chunks in the
    artifact system.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNKS_FIELD_NUMBER: builtins.int
    @property
    def chunks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Chunk]:
        """repeated chunks"""

    def __init__(
        self,
        *,
        chunks: collections.abc.Iterable[global___Chunk] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["chunks", b"chunks"]) -> None: ...

global___ListChunksResponse = ListChunksResponse

@typing.final
class GetChunkRequest(google.protobuf.message.Message):
    """GetChunkRequest represents a request to get a chunk.
    Follows AIP-131: https://google.aip.dev/131
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    CHUNK_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The resource name of the chunk to retrieve.
    Format:
    `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}/chunks/{chunk}`
    """
    chunk_type: global___Chunk.Type.ValueType
    """Optional chunk type filter. If specified, returns a chunk of this type
    from the same file. If not specified, returns the chunk identified by name.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        chunk_type: global___Chunk.Type.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_chunk_type", b"_chunk_type", "chunk_type", b"chunk_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_chunk_type", b"_chunk_type", "chunk_type", b"chunk_type", "name", b"name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_chunk_type", b"_chunk_type"]) -> typing.Literal["chunk_type"] | None: ...

global___GetChunkRequest = GetChunkRequest

@typing.final
class GetChunkResponse(google.protobuf.message.Message):
    """GetChunkResponse represents a response for getting a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def chunk(self) -> global___Chunk:
        """The chunk metadata, including markdown_reference for extracting content.
        Clients should use GetFile to fetch the full content/summary markdown,
        then use markdown_reference coordinates to extract the specific chunk text.
        """

    def __init__(
        self,
        *,
        chunk: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["chunk", b"chunk"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["chunk", b"chunk"]) -> None: ...

global___GetChunkResponse = GetChunkResponse

@typing.final
class UpdateChunkRequest(google.protobuf.message.Message):
    """UpdateChunkRequest represents a request to update a chunk.
    Follows AIP-134: https://google.aip.dev/134
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    RETRIEVABLE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The resource name of the chunk to update.
    Format:
    `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}/chunks/{chunk}`
    """
    retrievable: builtins.bool
    """whether the chunk is retrievable"""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        retrievable: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name", "retrievable", b"retrievable"]) -> None: ...

global___UpdateChunkRequest = UpdateChunkRequest

@typing.final
class UpdateChunkResponse(google.protobuf.message.Message):
    """UpdateChunkResponse represents a response for updating a chunk."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def chunk(self) -> global___Chunk:
        """chunk"""

    def __init__(
        self,
        *,
        chunk: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["chunk", b"chunk"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["chunk", b"chunk"]) -> None: ...

global___UpdateChunkResponse = UpdateChunkResponse

@typing.final
class SearchChunksRequest(google.protobuf.message.Message):
    """SearchChunksRequest represents a request to search for similar chunks."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENT_FIELD_NUMBER: builtins.int
    KNOWLEDGE_BASE_FIELD_NUMBER: builtins.int
    TEXT_PROMPT_FIELD_NUMBER: builtins.int
    TOP_K_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    FILE_MEDIA_TYPE_FIELD_NUMBER: builtins.int
    FILES_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    parent: builtins.str
    """The parent resource name (namespace).
    Format: `namespaces/{namespace}`
    """
    knowledge_base: builtins.str
    """The knowledge base resource name to filter by (optional).
    Format: `namespaces/{namespace}/knowledge-bases/{knowledge_base}`
    """
    text_prompt: builtins.str
    """Text prompt to look for similarities."""
    top_k: builtins.int
    """Top K. Default value: 5."""
    type: global___Chunk.Type.ValueType
    """Chunk type."""
    file_media_type: artifact.v1alpha.file_pb2.File.FileMediaType.ValueType
    """File media type."""
    @property
    def files(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """File resource names to filter by. When this field is provided, the response
        will return only chunks that belong to the specified files.
        Format:
        `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}`
        """

    @property
    def tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Tags to filter by. When multiple tags are provided, OR logic is applied.
        Note: File filter takes precedence over tags, as tags apply to files.
        """

    def __init__(
        self,
        *,
        parent: builtins.str = ...,
        knowledge_base: builtins.str = ...,
        text_prompt: builtins.str = ...,
        top_k: builtins.int = ...,
        type: global___Chunk.Type.ValueType = ...,
        file_media_type: artifact.v1alpha.file_pb2.File.FileMediaType.ValueType = ...,
        files: collections.abc.Iterable[builtins.str] | None = ...,
        tags: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["file_media_type", b"file_media_type", "files", b"files", "knowledge_base", b"knowledge_base", "parent", b"parent", "tags", b"tags", "text_prompt", b"text_prompt", "top_k", b"top_k", "type", b"type"]) -> None: ...

global___SearchChunksRequest = SearchChunksRequest

@typing.final
class SearchChunksResponse(google.protobuf.message.Message):
    """SearchChunksResponse represents a response for searching similar chunks."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIMILAR_CHUNKS_FIELD_NUMBER: builtins.int
    @property
    def similar_chunks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SimilarityChunk]:
        """chunks"""

    def __init__(
        self,
        *,
        similar_chunks: collections.abc.Iterable[global___SimilarityChunk] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["similar_chunks", b"similar_chunks"]) -> None: ...

global___SearchChunksResponse = SearchChunksResponse

@typing.final
class SimilarityChunk(google.protobuf.message.Message):
    """SimilarityChunk represents a chunk with similarity score."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHUNK_FIELD_NUMBER: builtins.int
    SIMILARITY_SCORE_FIELD_NUMBER: builtins.int
    TEXT_CONTENT_FIELD_NUMBER: builtins.int
    FILE_FIELD_NUMBER: builtins.int
    CHUNK_METADATA_FIELD_NUMBER: builtins.int
    chunk: builtins.str
    """Chunk resource name.
    Full resource name:
    namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}/chunks/{chunk}
    """
    similarity_score: builtins.float
    """Similarity score."""
    text_content: builtins.str
    """Content."""
    file: builtins.str
    """Source file resource name.
    Full resource name:
    namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}
    """
    @property
    def chunk_metadata(self) -> global___Chunk:
        """Chunk metadata."""

    def __init__(
        self,
        *,
        chunk: builtins.str = ...,
        similarity_score: builtins.float = ...,
        text_content: builtins.str = ...,
        file: builtins.str = ...,
        chunk_metadata: global___Chunk | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["chunk_metadata", b"chunk_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["chunk", b"chunk", "chunk_metadata", b"chunk_metadata", "file", b"file", "similarity_score", b"similarity_score", "text_content", b"text_content"]) -> None: ...

global___SimilarityChunk = SimilarityChunk
